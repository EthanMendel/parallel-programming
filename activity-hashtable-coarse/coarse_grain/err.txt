td=c++17 -O3   -c -o main.o main.cpp
In file included from main.cpp:9:
MyHashtable.cpp: In instantiation of ‘V MyHashtable<K, V>::get(const K&) const [with K = std::__cxx11::basic_string<char>; V = std::mutex]’:
MyHashtable.cpp:107:13:   required from here
MyHashtable.cpp:114:21: error: use of deleted function ‘std::mutex::mutex(const std::mutex&)’
  114 |        return node->value;
      |                     ^~~~~
In file included from /usr/include/c++/9/mutex:43,
                 from main.cpp:5:
/usr/include/c++/9/bits/std_mutex.h:94:5: note: declared here
   94 |     mutex(const mutex&) = delete;
      |     ^~~~~
In file included from main.cpp:9:
MyHashtable.cpp: In instantiation of ‘void MyHashtable<K, V>::set(const K&, const V&) [with K = std::__cxx11::basic_string<char>; V = std::mutex]’:
MyHashtable.cpp:125:16:   required from here
MyHashtable.cpp:132:20: error: use of deleted function ‘std::mutex& std::mutex::operator=(const std::mutex&)’
  132 |        node->value = value;
      |        ~~~~~~~~~~~~^~~~~~~
In file included from /usr/include/c++/9/mutex:43,
                 from main.cpp:5:
/usr/include/c++/9/bits/std_mutex.h:95:12: note: declared here
   95 |     mutex& operator=(const mutex&) = delete;
      |            ^~~~~~~~
In file included from /usr/include/c++/9/bits/stl_algobase.h:64,
                 from /usr/include/c++/9/bits/char_traits.h:39,
                 from /usr/include/c++/9/ios:40,
                 from /usr/include/c++/9/istream:38,
                 from /usr/include/c++/9/fstream:38,
                 from main.cpp:2:
/usr/include/c++/9/bits/stl_pair.h: In instantiation of ‘constexpr std::pair<typename std::__decay_and_strip<_Tp>::__type, typename std::__decay_and_strip<_T2>::__type> std::make_pair(_T1&&, _T2&&) [with _T1 = std::__cxx11::basic_string<char>&; _T2 = std::mutex&; typename std::__decay_and_strip<_T2>::__type = std::mutex; typename std::__decay_and_strip<_Tp>::__type = std::__cxx11::basic_string<char>]’:
MyHashtable.cpp:77:28:   required from ‘std::pair<_T1, _T2> MyHashtable<K, V>::hashtable_iter::operator*() [with K = std::__cxx11::basic_string<char>; V = std::mutex]’
MyHashtable.cpp:76:28:   required from here
/usr/include/c++/9/bits/stl_pair.h:529:14: error: no matching function for call to ‘std::pair<std::__cxx11::basic_string<char>, std::mutex>::pair(std::__cxx11::basic_string<char>&, std::mutex&)’
  529 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/9/bits/stl_pair.h:436:9: note: candidate: ‘template<class ... _Args1, long unsigned int ..._Indexes1, class ... _Args2, long unsigned int ..._Indexes2> std::pair<_T1, _T2>::pair(std::tuple<_Args1 ...>&, std::tuple<_Args2 ...>&, std::_Index_tuple<_Indexes1 ...>, std::_Index_tuple<_Indexes2 ...>)’
  436 |         pair(tuple<_Args1...>&, tuple<_Args2...>&,
      |         ^~~~
/usr/include/c++/9/bits/stl_pair.h:436:9: note:   template argument deduction/substitution failed:
/usr/include/c++/9/bits/stl_pair.h:529:14: note:   ‘std::__cxx11::basic_string<char>’ is not derived from ‘std::tuple<_Tps ...>’
  529 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/9/bits/stl_pair.h:375:9: note: candidate: ‘template<class ... _Args1, class ... _Args2> std::pair<_T1, _T2>::pair(std::piecewise_construct_t, std::tuple<_Args1 ...>, std::tuple<_Args2 ...>)’
  375 |         pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
      |         ^~~~
/usr/include/c++/9/bits/stl_pair.h:375:9: note:   template argument deduction/substitution failed:
/usr/include/c++/9/bits/stl_pair.h:529:14: note:   ‘std::mutex’ is not derived from ‘std::tuple<_Tps ...>’
  529 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/9/bits/stl_pair.h:370:21: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<(std::_PCC<((! std::is_same<std::__cxx11::basic_string<char>, _U1>::value) || (! std::is_same<std::mutex, _U2>::value)), std::__cxx11::basic_string<char>, std::mutex>::_MoveConstructiblePair<_U1, _U2>() && (! std::_PCC<((! std::is_same<std::__cxx11::basic_string<char>, _U1>::value) || (! std::is_same<std::mutex, _U2>::value)), std::__cxx11::basic_string<char>, std::mutex>::_ImplicitlyMoveConvertiblePair<_U1, _U2>())), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(std::pair<_U1, _U2>&&)’
  370 |  explicit constexpr pair(pair<_U1, _U2>&& __p)
      |                     ^~~~
/usr/include/c++/9/bits/stl_pair.h:370:21: note:   template argument deduction/substitution failed:
/usr/include/c++/9/bits/stl_pair.h:529:14: note:   ‘std::__cxx11::basic_string<char>’ is not derived from ‘std::pair<_T1, _T2>’
  529 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/9/bits/stl_pair.h:360:12: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<(std::_PCC<((! std::is_same<std::__cxx11::basic_string<char>, _U1>::value) || (! std::is_same<std::mutex, _U2>::value)), std::__cxx11::basic_string<char>, std::mutex>::_MoveConstructiblePair<_U1, _U2>() && std::_PCC<((! std::is_same<std::__cxx11::basic_string<char>, _U1>::value) || (! std::is_same<std::mutex, _U2>::value)), std::__cxx11::basic_string<char>, std::mutex>::_ImplicitlyMoveConvertiblePair<_U1, _U2>()), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(std::pair<_U1, _U2>&&)’
  360 |  constexpr pair(pair<_U1, _U2>&& __p)
      |            ^~~~
/usr/include/c++/9/bits/stl_pair.h:360:12: note:   template argument deduction/substitution failed:
/usr/include/c++/9/bits/stl_pair.h:529:14: note:   ‘std::__cxx11::basic_string<char>’ is not derived from ‘std::pair<_T1, _T2>’
  529 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/9/bits/stl_pair.h:350:21: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<(_MoveConstructiblePair<_U1, _U2>() && (! _ImplicitlyMoveConvertiblePair<_U1, _U2>())), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(_U1&&, _U2&&)’
  350 |  explicit constexpr pair(_U1&& __x, _U2&& __y)
      |                     ^~~~
/usr/include/c++/9/bits/stl_pair.h:350:21: note:   template argument deduction/substitution failed:
/usr/include/c++/9/bits/stl_pair.h:349:38: error: no type named ‘type’ in ‘struct std::enable_if<false, bool>’
  349 |                          bool>::type=false>
      |                                      ^~~~~
/usr/include/c++/9/bits/stl_pair.h:341:12: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<(_MoveConstructiblePair<_U1, _U2>() && _ImplicitlyMoveConvertiblePair<_U1, _U2>()), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(_U1&&, _U2&&)’
  341 |  constexpr pair(_U1&& __x, _U2&& __y)
      |            ^~~~
/usr/include/c++/9/bits/stl_pair.h:341:12: note:   template argument deduction/substitution failed:
/usr/include/c++/9/bits/stl_pair.h:340:38: error: no type named ‘type’ in ‘struct std::enable_if<false, bool>’
  340 |                          bool>::type=true>
      |                                      ^~~~
/usr/include/c++/9/bits/stl_pair.h:332:17: note: candidate: ‘template<class _U2, typename std::enable_if<_CopyMovePair<false, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, _U2>(), bool>::type <anonymous> > std::pair<_T1, _T2>::pair(const _T1&, _U2&&)’
  332 |        explicit pair(const _T1& __x, _U2&& __y)
      |                 ^~~~
/usr/include/c++/9/bits/stl_pair.h:332:17: note:   template argument deduction/substitution failed:
/usr/include/c++/9/bits/stl_pair.h:331:38: error: no type named ‘type’ in ‘struct std::enable_if<false, bool>’
  331 |                          bool>::type=false>
      |                                      ^~~~~
/usr/include/c++/9/bits/stl_pair.h:325:18: note: candidate: ‘template<class _U2, typename std::enable_if<_CopyMovePair<true, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, _U2>(), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(const _T1&, _U2&&)’
  325 |        constexpr pair(const _T1& __x, _U2&& __y)
      |                  ^~~~
/usr/include/c++/9/bits/stl_pair.h:325:18: note:   template argument deduction/substitution failed:
/usr/include/c++/9/bits/stl_pair.h:324:38: error: no type named ‘type’ in ‘struct std::enable_if<false, bool>’
  324 |                          bool>::type=true>
      |                                      ^~~~
/usr/include/c++/9/bits/stl_pair.h:318:27: note: candidate: ‘template<class _U1, typename std::enable_if<_MoveCopyPair<false, _U1, std::mutex>(), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(_U1&&, const _T2&)’
  318 |        explicit constexpr pair(_U1&& __x, const _T2& __y)
      |                           ^~~~
/usr/include/c++/9/bits/stl_pair.h:318:27: note:   template argument deduction/substitution failed:
/usr/include/c++/9/bits/stl_pair.h:317:38: error: no type named ‘type’ in ‘struct std::enable_if<false, bool>’
  317 |                          bool>::type=false>
      |                                      ^~~~~
/usr/include/c++/9/bits/stl_pair.h:311:18: note: candidate: ‘template<class _U1, typename std::enable_if<_MoveCopyPair<true, _U1, std::mutex>(), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(_U1&&, const _T2&)’
  311 |        constexpr pair(_U1&& __x, const _T2& __y)
      |                  ^~~~
/usr/include/c++/9/bits/stl_pair.h:311:18: note:   template argument deduction/substitution failed:
/usr/include/c++/9/bits/stl_pair.h:310:38: error: no type named ‘type’ in ‘struct std::enable_if<false, bool>’
  310 |                          bool>::type=true>
      |                                      ^~~~
/usr/include/c++/9/bits/stl_pair.h:300:21: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<(std::_PCC<((! std::is_same<std::__cxx11::basic_string<char>, _U1>::value) || (! std::is_same<std::mutex, _U2>::value)), std::__cxx11::basic_string<char>, std::mutex>::_ConstructiblePair<_U1, _U2>() && (! std::_PCC<((! std::is_same<std::__cxx11::basic_string<char>, _U1>::value) || (! std::is_same<std::mutex, _U2>::value)), std::__cxx11::basic_string<char>, std::mutex>::_ImplicitlyConvertiblePair<_U1, _U2>())), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(const std::pair<_U1, _U2>&)’
  300 |  explicit constexpr pair(const pair<_U1, _U2>& __p)
      |                     ^~~~
/usr/include/c++/9/bits/stl_pair.h:300:21: note:   template argument deduction/substitution failed:
/usr/include/c++/9/bits/stl_pair.h:529:14: note:   ‘std::__cxx11::basic_string<char>’ is not derived from ‘const std::pair<_T1, _T2>’
  529 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/9/bits/stl_pair.h:291:19: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<(std::_PCC<((! std::is_same<std::__cxx11::basic_string<char>, _U1>::value) || (! std::is_same<std::mutex, _U2>::value)), std::__cxx11::basic_string<char>, std::mutex>::_ConstructiblePair<_U1, _U2>() && std::_PCC<((! std::is_same<std::__cxx11::basic_string<char>, _U1>::value) || (! std::is_same<std::mutex, _U2>::value)), std::__cxx11::basic_string<char>, std::mutex>::_ImplicitlyConvertiblePair<_U1, _U2>()), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(const std::pair<_U1, _U2>&)’
  291 |         constexpr pair(const pair<_U1, _U2>& __p)
      |                   ^~~~
/usr/include/c++/9/bits/stl_pair.h:291:19: note:   template argument deduction/substitution failed:
/usr/include/c++/9/bits/stl_pair.h:529:14: note:   ‘std::__cxx11::basic_string<char>’ is not derived from ‘const std::pair<_T1, _T2>’
  529 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/9/bits/stl_pair.h:269:26: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<(_ConstructiblePair<_U1, _U2>() && (! _ImplicitlyConvertiblePair<_U1, _U2>())), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(const _T1&, const _T2&)’
  269 |       explicit constexpr pair(const _T1& __a, const _T2& __b)
      |                          ^~~~
/usr/include/c++/9/bits/stl_pair.h:269:26: note:   template argument deduction/substitution failed:
/usr/include/c++/9/bits/stl_pair.h:268:38: error: no type named ‘type’ in ‘struct std::enable_if<false, bool>’
  268 |                          bool>::type=false>
      |                                      ^~~~~
/usr/include/c++/9/bits/stl_pair.h:260:17: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<(_ConstructiblePair<_U1, _U2>() && _ImplicitlyConvertiblePair<_U1, _U2>()), bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair(const _T1&, const _T2&)’
  260 |       constexpr pair(const _T1& __a, const _T2& __b)
      |                 ^~~~
/usr/include/c++/9/bits/stl_pair.h:260:17: note:   template argument deduction/substitution failed:
/usr/include/c++/9/bits/stl_pair.h:259:38: error: no type named ‘type’ in ‘struct std::enable_if<false, bool>’
  259 |                          bool>::type=true>
      |                                      ^~~~
/usr/include/c++/9/bits/stl_pair.h:242:26: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<std::__and_<std::is_default_constructible<_Tp>, std::is_default_constructible<_Dp>, std::__not_<std::__and_<std::__is_implicitly_default_constructible<_U1>, std::__is_implicitly_default_constructible<_U2> > > >::value, bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair()’
  242 |       explicit constexpr pair()
      |                          ^~~~
/usr/include/c++/9/bits/stl_pair.h:242:26: note:   template argument deduction/substitution failed:
/usr/include/c++/9/bits/stl_pair.h:529:14: note:   candidate expects 0 arguments, 2 provided
  529 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/9/bits/stl_pair.h:229:26: note: candidate: ‘template<class _U1, class _U2, typename std::enable_if<std::__and_<std::__is_implicitly_default_constructible<_U1>, std::__is_implicitly_default_constructible<_U2> >::value, bool>::type <anonymous> > constexpr std::pair<_T1, _T2>::pair()’
  229 |       _GLIBCXX_CONSTEXPR pair()
      |                          ^~~~
/usr/include/c++/9/bits/stl_pair.h:229:26: note:   template argument deduction/substitution failed:
/usr/include/c++/9/bits/stl_pair.h:529:14: note:   candidate expects 0 arguments, 2 provided
  529 |       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
make: *** [<builtin>: main.o] Error 1

